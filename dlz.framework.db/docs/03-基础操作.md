# DLZ-DB 帮助文档 - 基础操作

## 3.1 查询操作

### 3.1.1、Wrapper 查询（推荐）

#### 3.1.1.1 查询单条记录

```java
// 方式1：返回 Bean
User user = DB.Wrapper.select(User.class)
    .eq(User::getId, 1)
    .query();

// 方式2：返回 ResultMap
ResultMap result = DB.Wrapper.select(User.class)
    .eq(User::getId, 1)
    .query();

```

#### 3.1.1.2 查询列表

```java
// 查询全部
List<User> all = DB.Wrapper.select(User.class).list();

// 条件查询
List<User> users = DB.Wrapper.select(User.class)
    .eq(User::getStatus, 1)
    .gt(User::getAge, 18)
    .orderByDesc(User::getCreateTime)
    .list();
```

#### 3.1.1.3 查询数量

```java
long count = DB.Wrapper.select(User.class)
    .eq(User::getStatus, 1)
    .count();
```

#### 3.1.1.4 查询指定字段

```java
List<User> users = DB.Wrapper.select(User.class)
    .select(User::getId, User::getName, User::getAge)
    .eq(User::getStatus, 1)
    .list();

// 生成 SQL：SELECT id, name, age FROM user WHERE status = 1
```

#### 3.1.1.5 查询字段

```java
List<String> cities = DB.Wrapper.select(User.class)
    .select(User::getCity)
    .queryStrList(String.class);


String citie = DB.Wrapper.select(User.class)
        .select(User::getCity)
        .ed(User::getId,1)
        .queryStr(String.class);
```

---

### 3.1.2、Maker 查询（表名方式）

#### 3.1.2.1 基础查询

```java
// 查询单条
ResultMap result = DB.Wrapper.select("user")
    .eq("id", 1)
    .query();
// 查询单条
User user = DB.Wrapper.select("user")
    .eq("id", 1)
    .query(User.class);

// 查询列表
List<ResultMap> list = DB.Wrapper.select("user")
    .eq("status", 1)
    .list();

// 转换为 Bean
List<User> users = DB.Wrapper.select("user")
    .eq("status", 1)
    .list(User.class);
```

#### 3.1.2.2 动态表名

```java
String tableName = "user_" + year;  // 如 user_2024

List<ResultMap> list = DB.Wrapper.select(tableName)
    .eq("status", 1)
    .list();
```

---

### 3.1.3、原生 SQL 查询

#### 3.1.3.1 使用占位符 ?

```java
// 单个结果：ResultMap
ResultMap result = DB.Jdbc.select("select * from user where id = ?",1)
        .query();

// 单个结果：User
User user = DB.Jdbc.select("select * from user where id = ?",1)
        .query(User.class);

// 列表结果
List<ResultMap> list = DB.Jdbc.select(
    "SELECT * FROM user WHERE status = ? AND age > ?", 
    1, 18
).queryList();

// 单个值
String name = DB.Jdbc.select(
    "SELECT name FROM user WHERE id = ?", 
    1
).queryStr();

// 值列表
List<Long> ids = DB.Jdbc.select(
    "SELECT id FROM user WHERE status = ?", 
    1
).queryList(Long.class);
```

#### 3.1.3.2 复杂查询
```java
//sql 预设到xml：key.user.getUserWithDept
String sql = """
        SELECT u.*, d.name as dept_name
        FROM user u
        LEFT JOIN department d ON u.dept_id = d.id
        WHERE u.status = ? AND d.type = ?
        ORDER BY u.create_time DESC
        """;
List<ResultMap> list = DB.Jdbc.select(sql, 1, "tech").queryList();
```

---

### 3.1.4、预设 SQL 查询

#### 3.1.4.1 基础使用
```xml
<sql sqlId="key.user.getUserWithDept"><![CDATA[
      SELECT u.*, d.name as dept_name
        FROM user u
   LEFT JOIN department d ON u.dept_id = d.id
       WHERE 1=1
        [and u.status = #{status}]
        [AND d.type = #{type}]
]]></sql>
```

```java
//sql 预设到xml：key.user.getUserWithDept
List<ResultMap> list = DB.Sql.select("key.user.getUserWithDept")
        .para("status", 1)
        .para("type", "tech")
        .queryList();
```
> 详见「第八章：预设 SQL」

---

### 3.1.5、结果处理

#### 3.1.5.1 返回类型

| 方法           | 返回类型 | 说明 |
|--------------|---------|------|
| `.query()`   | Bean / null | 单条记录，无则返回 null |
| `.queryMap()`  | ResultMap / null | 单条记录，Map 形式 |
| `.list()`    | List<Bean> | 列表 |
| `.listMap()` | List<ResultMap> | 列表，Map 形式 |
| `.count()`   | long | 数量 |
| `.page()`    | Page<Bean> | 分页结果 |

#### 3.1.5.2 ResultMap 深度取值

```java
ResultMap result = DB.Wrapper.select("user")
    .eq("id", 1)
    .query();

// 基础取值
String name = result.getStr("name");
Integer age = result.getInt("age", 0);  // 带默认值

// 深度取值（假设有嵌套 JSON 字段）
String city = result.getStr("address.city", "未知");
List<Order> orders = result.getList("orders", Order.class);

// 负数索引
String lastTag = result.getStr("tags[-1]");  // 最后一个标签
```

---

## 3.2 插入操作

### 3.2.1、Wrapper 插入（推荐）

#### 3.2.1.1 基础插入

```java
User user = new User();
user.setName("张三");
user.setAge(25);
user.setEmail("zhangsan@example.com");

// 插入（不返回主键）
DB.insert(user).execute();

// 插入并返回自增主键
Long id = DB.insert(user).insertWithAutoKey();
System.out.println("新用户 ID：" + id);
```

#### 3.2.1.2 插入非空字段

```java
User user = new User();
user.setName("张三");
// age 和 email 为 null，不会插入

DB.insert(user).execute();

// 生成 SQL：INSERT INTO user (name) VALUES ('张三')
```

---

### 3.2.2、Maker 插入（表名方式）

#### 3.2.2.1 基础插入

```java
DB.insert("user")
    .value("name", "张三")
    .value("age", 25)
    .value("email", "zhangsan@example.com")
    .value("create_time", new Date())
    .execute();
```

#### 3.2.2.2 使用 Map 插入

```java
Map<String, Object> data = new HashMap<>();
data.put("name", "张三");
data.put("age", 25);
data.put("email", "zhangsan@example.com");

DB.insert("user").value(data).execute();
```

#### 3.2.2.3 返回自增主键

```java
Long id = DB.insert("user")
    .value("name", "张三")
    .value("age", 25)
    .insertWithAutoKey();
```

---

### 3.2.3、批量插入

#### 3.2.3.1 批量插入 Bean 列表

```java
List<User> users = Arrays.asList(
    new User("张三", 25),
    new User("李四", 30),
    new User("王五", 28)
);

DB.saveBatch(users);
DB.saveBatch(users,100);//每个批次100条
```

[//]: # (### 3.2 批量插入 Map 列表)

[//]: # ()
[//]: # (```java)

[//]: # (List<Map<String, Object>> dataList = new ArrayList<>&#40;&#41;;)

[//]: # (dataList.add&#40;Map.of&#40;"name", "张三", "age", 25&#41;&#41;;)

[//]: # (dataList.add&#40;Map.of&#40;"name", "李四", "age", 30&#41;&#41;;)

[//]: # ()
[//]: # (DB.saveBatch&#40;"user", dataList&#41;.execute&#40;&#41;;)

[//]: # (```)

---

### 3.2.4、插入或更新

#### 3.2.4.1 存在则更新，不存在则插入

```java
User user = new User();
user.setId(1L);  // 主键
user.setName("张三");
user.setAge(26);

DB.insertOrUpdate(user).execute();

// 如果 id=1 存在 → UPDATE
// 如果 id=1 不存在 → INSERT
```

---

## 3.3 更新操作

### 3.3.1、Wrapper 更新（推荐）

#### 3.3.1.1 根据条件更新

```java
User user = new User();
user.setName("李四");
user.setAge(30);

DB.Wrapper.update(user)
    .eq(User::getId, 1)
    .execute();

// 生成 SQL：
// UPDATE user SET name='李四', age=30 
// WHERE id = 1 AND is_deleted = 0
```

#### 3.3.1.2 更新指定字段

```java
DB.Wrapper.update(User.class)
    .set(User::getName, "李四")
    .set(User::getUpdateTime, new Date())
    .eq(User::getId, 1)
    .execute();
```

#### 3.3.1.3 条件更新

```java
DB.Wrapper.update(User.class)
    .set(User::getStatus, 0)
    .eq(User::getType, 1)
    .lt(User::getLastLoginTime, DateUtil.addDays(new Date(), -30))
    .execute();

// 将 30 天未登录的用户设为禁用
```

---

### 3.3.2、Maker 更新（表名方式）

#### 3.3.2.1 基础更新

```java
DB.Table.update("user")
    .set("name", "李四")
    .set("update_time", new Date())
    .where(Condition.where()
        .eq("id", 1)
    )
    .execute();
```

#### 3.3.2.2 复杂条件更新

```java
DB.Table.update("user")
    .set("status", 1)
    .where(Condition.where()
        .eq("type", 1)
        .and(w -> w
            .eq("level", 3)
            .gt("score", 100)
        )
        .or(w -> w
            .eq("vip", 1)
        )
    )
    .execute();

// 生成 SQL：
// UPDATE user SET status = 1 
// WHERE type = 1 
//   AND (level = 3 AND score > 100) 
//   OR (vip = 1) 
//   AND is_deleted = 0
```

#### 3.3.2.3 表达式更新

```java
// 数值增减
DB.Table.update("user")
    .setSql("score = score + 10")
    .setSql("login_count = login_count + 1")
    .eq("id", 1)
    .execute();

// 生成 SQL：
// UPDATE user SET score = score + 10, login_count = login_count + 1 
// WHERE id = 1
```

### 3.3.3、安全机制

#### 3.3.3.1 必须有条件

```java
// ❌ 无条件更新会被拦截或添加安全条件
DB.Wrapper.update(User.class)
    .set(User::getStatus, 0)
    .execute();

// 生成 SQL（自动添加 is_deleted 条件）：
// UPDATE user SET status = 0 WHERE is_deleted = 0
// 不会更新全表！
```

#### 3.3.32 逻辑删除自动添加

```java
// Bean 有 isDeleted 字段时，自动添加条件
DB.Wrapper.update(user).eq(User::getId, 1).execute();

// 生成 SQL：
// UPDATE user SET ... WHERE id = 1 AND is_deleted = 0
```

---

## 3.4 删除操作

### 3.4.1、Wrapper 删除（推荐）

#### 3.4.1.1 条件删除

```java
DB.delete(User.class)
    .eq(User::getId, 1)
    .execute();

// 生成 SQL（逻辑删除）：
// UPDATE user SET is_deleted = 1 WHERE id = 1 AND is_deleted = 0
// 或（物理删除）：
// DELETE FROM user WHERE id = 1 AND is_deleted = 0
```

#### 3.4.1.2 复杂条件删除

```java
DB.delete(User.class)
    .eq(User::getStatus, 0)
    .lt(User::getCreateTime, DateUtil.addDays(new Date(), -365))
    .execute();

// 删除一年前已禁用的用户
```

---

### 3.4.2、Maker 删除（表名方式）

#### 3.4.2.1 基础删除

```java
DB.delete("user")
    .eq("id", 1)
    .execute();
```

#### 3.4.2.2 复杂条件删除

```java
Condition where = Condition.where()
    .eq("status", 0)
    .and(w -> w.eq("type", 1).eq("level", 0))
    .or(w -> w.lt("expire_time", new Date()));

DB.delete("user").where(where).execute();

// 生成 SQL：
// DELETE FROM user 
// WHERE status = 0 
//   AND (type = 1 AND level = 0) 
//   OR (expire_time < '2024-01-01') 
//   AND is_deleted = 0
```

---

### 3.4.3、逻辑删除

#### 3.4.3.1 自动逻辑删除

当 Bean 中存在 `isDeleted` 字段时，DLZ-DB 自动：

1. **删除时**：UPDATE 设置删除标记，而非真正 DELETE
2. **查询时**：自动添加 `is_deleted = 0` 条件
3. **更新时**：自动添加 `is_deleted = 0` 条件

```java
// 执行删除
DB.delete(User.class).eq(User::getId, 1).execute();

// 实际执行的 SQL：
// UPDATE user SET is_deleted = 1 WHERE id = 1 AND is_deleted = 0
```

#### 3.4.3.2 配置逻辑删除

```yaml
dlz:
  db:
    # 逻辑删除字段名
    logic-delete-field: is_deleted
```

#### 3.4.3.3 物理删除

```java
// 如果确实需要物理删除
DB.deletePhysical(User.class)
    .eq(User::getId, 1)
    .execute();

// 执行真正的 DELETE FROM user WHERE id = 1
```

---

### 3.4.3、安全机制

#### 3.4.4.1 无条件删除保护

```java
// ❌ 无条件删除会被安全处理
DB.delete(User.class).execute();

// 生成 SQL（只会删除逻辑未删除的）：
// DELETE FROM user WHERE is_deleted = 0
// 而不是 DELETE FROM user（不会删全表）
```

#### 3.4.4.2 删除前确认

```java
// 先查询数量，确认影响范围
long count = DB.Wrapper.select(User.class)
    .eq(User::getStatus, 0)
    .lt(User::getCreateTime, someDate)
    .count();

if (count < 1000) {  // 确保不会误删太多
    DB.delete(User.class)
        .eq(User::getStatus, 0)
        .lt(User::getCreateTime, someDate)
        .execute();
}
```
