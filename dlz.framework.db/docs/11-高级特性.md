# DLZ-DB 帮助文档 - 高级特性

## 11.1 逻辑删除

### 自动识别

当 Bean 中存在以下字段时，自动启用逻辑删除：
- `isDeleted`
- `deleted`
- `is_deleted`（配置指定）

### 配置

```yaml
dlz:
  db:
    # 逻辑删除字段
    logic-delete-field: is_deleted
    # 已删除值
    logic-delete-value: 1
    # 未删除值
    logic-not-delete-value: 0
```

### 自动行为

#### 查询自动过滤

```java
DB.Pojo.select(User.class).eq(User::getStatus, 1).list();

// 自动添加条件：
// SELECT * FROM user WHERE status = 1 AND is_deleted = 0
```

#### 删除变更新

```java
DB.Pojo.delete(User.class).eq(User::getId, 1).execute();

// 实际执行：
// UPDATE user SET is_deleted = 1 WHERE id = 1 AND is_deleted = 0
```

#### 更新自动过滤

```java
DB.Pojo.update(user).eq(User::getId, 1).execute();

// 自动添加条件：
// UPDATE user SET ... WHERE id = 1 AND is_deleted = 0
```

### 查询已删除数据

```java
// 临时忽略逻辑删除
DB.Pojo.select(User.class)
    .ignoreLogicDelete()
    .eq(User::getId, 1)
    .one();

// 生成 SQL（无 is_deleted 条件）：
// SELECT * FROM user WHERE id = 1
```

### 物理删除

```java
// 真正删除数据
DB.deletePhysical(User.class)
    .eq(User::getId, 1)
    .execute();

// 执行：DELETE FROM user WHERE id = 1
```
---

## 11.2 批量操作

### 批量插入

```java
List<User> users = Arrays.asList(
    new User("张三", 25),
    new User("李四", 30),
    new User("王五", 28)
);

// 批量插入
int count = DB.insertBatch(users).execute();

// 批量插入并返回主键
List<Long> ids = DB.insertBatch(users).insertWithAutoKeys();
```

### 批量更新

```java
// 方式1：循环更新
users.forEach(user -> {
    DB.Pojo.update(user).eq(User::getId, user.getId()).execute();
});

// 方式2：条件批量更新
DB.Pojo.update(User.class)
    .set(User::getStatus, 0)
    .in(User::getId, Arrays.asList(1, 2, 3, 4, 5))
    .execute();
```

### 批量删除

```java
DB.delete(User.class)
    .in(User::getId, Arrays.asList(1, 2, 3, 4, 5))
    .execute();

// 或使用字符串
DB.delete(User.class)
    .in(User::getId, "1,2,3,4,5")
    .execute();
```

### 性能建议

```java
// ❌ 避免循环单条操作
for (User user : users) {
    DB.insert(user).execute();  // 每次都是独立连接
}

// ✅ 使用批量操作
DB.insertBatch(users).execute();  // 一次连接，批量执行
```
---

## 11.3 事务管理

### 声明式事务（推荐）

```java
@Service
public class OrderService {

    @Transactional
    public void createOrder(Order order, List<OrderItem> items) {
        // 插入订单
        Long orderId = DB.insert(order).insertWithAutoKey();
        
        // 插入订单项
        items.forEach(item -> {
            item.setOrderId(orderId);
            DB.insert(item).execute();
        });
        
        // 扣减库存
        items.forEach(item -> {
            DB.Table.update("product")
                .setSql("stock = stock - " + item.getQuantity())
                .eq("id", item.getProductId())
                .execute();
        });
        
        // 任何异常都会回滚
    }
}
```

### 事务传播

```java
@Transactional(propagation = Propagation.REQUIRED)
public void methodA() {
    // 默认传播行为：存在事务则加入，否则创建新事务
}

@Transactional(propagation = Propagation.REQUIRES_NEW)
public void methodB() {
    // 总是创建新事务
}

@Transactional(propagation = Propagation.NESTED)
public void methodC() {
    // 嵌套事务（支持保存点）
}
```

### 只读事务

```java
@Transactional(readOnly = true)
public List<User> findAll() {
    return DB.Pojo.select(User.class).list();
}
```

### 异常回滚

```java
// 默认只回滚 RuntimeException
@Transactional

// 回滚所有异常
@Transactional(rollbackFor = Exception.class)

// 不回滚特定异常
@Transactional(noRollbackFor = BusinessException.class)
```