# DLZ-DB 帮助文档 - 条件构造器

## 4.1 基础条件

### 条件方法一览

| 方法 | 说明 | SQL 示例 |
|------|------|---------|
| `eq(字段, 值)` | 等于 | `field = value` |
| `ne(字段, 值)` | 不等于 | `field <> value` |
| `gt(字段, 值)` | 大于 | `field > value` |
| `ge(字段, 值)` | 大于等于 | `field >= value` |
| `lt(字段, 值)` | 小于 | `field < value` |
| `le(字段, 值)` | 小于等于 | `field <= value` |
| `isNull(字段)` | 为空 | `field IS NULL` |
| `isNotNull(字段)` | 不为空 | `field IS NOT NULL` |

    isn("#n is null"),//为空
    isnn("#n is not null"),//不为空
    eq("#n = #{#k}"),
    lt("#n < #{#k}"),//小于
    le("#n <= #{#k}"),//小于等于
    gt("#n > #{#k}"),//大于
    ge("#n >= #{#k}"),//大于等于
    ne("#n <> #{#k}"),//不等于
    in("#n in (${#k})"),
    ni("#n not in (${#k})"),
    lk("#n like #{#k}"),//like:%xxx%
    ll("#n like #{#k}"),//左like:xxx%
    lr("#n like #{#k}"),//右like：%xxx
    nl("#n not like #{#k}"),//不like
    bt("#n between #{#k1} and #{#k2}"),//BETWEEN 值1 AND 值2
    nb("#n not between #{#k1} and #{#k2}");//BETWEEN 值1 AND 值2


### 使用示例

#### Lambda 方式（推荐）

```java
DB.query(User.class)
    .eq(User::getStatus, 1)       // status = 1
    .ne(User::getType, 0)         // type <> 0
    .gt(User::getAge, 18)         // age > 18
    .ge(User::getScore, 60)       // score >= 60
    .lt(User::getLevel, 10)       // level < 10
    .le(User::getRetryCount, 3)   // retry_count <= 3
    .isNull(User::getDeleteTime)  // delete_time IS NULL
    .isNotNull(User::getEmail)    // email IS NOT NULL
    .list();
```

#### 字符串方式

```java
DB.query("user")
    .eq("status", 1)
    .gt("age", 18)
    .isNull("delete_time")
    .list();
```

### 条件执行控制

#### 条件判断

```java
String name = request.getParameter("name");  // 可能为 null
Integer status = request.getParameter("status");

DB.query(User.class)
    // 第一个参数为 true 时才添加条件
    .eq(status != null, User::getStatus, status)
    .like(StringUtil.isNotBlank(name), User::getName, name)
    .list();

// 如果 name 为空，则不会添加 LIKE 条件
```

#### 链式条件控制

```java
WrapperQuery<User> query = DB.query(User.class);

if (status != null) {
    query.eq(User::getStatus, status);
}
if (StringUtil.isNotBlank(name)) {
    query.like(User::getName, name);
}
if (minAge != null) {
    query.ge(User::getAge, minAge);
}

List<User> users = query.list();
```
---

## 4.2 逻辑组合（AND / OR）

### 默认逻辑

多个条件默认使用 **AND** 连接：

```java
DB.query(User.class)
    .eq(User::getStatus, 1)
    .gt(User::getAge, 18)
    .like(User::getName, "张")
    .list();

// 生成 SQL：
// WHERE status = 1 AND age > 18 AND name LIKE '%张%'
```

### OR 条件

#### 简单 OR

```java
DB.query(User.class)
    .eq(User::getStatus, 1)
    .or(w -> w
        .eq(User::getType, 1)
        .eq(User::getType, 2)
    )
    .list();

// 生成 SQL：
// WHERE status = 1 AND (type = 1 OR type = 2)
```

#### 复杂 OR

```java
DB.query(User.class)
    .or(w -> w
        .eq(User::getCity, "北京")
        .eq(User::getCity, "上海")
        .eq(User::getCity, "广州")
    )
    .gt(User::getAge, 18)
    .list();

// 生成 SQL：
// WHERE (city = '北京' OR city = '上海' OR city = '广州') AND age > 18
```

### AND 嵌套

```java
DB.query(User.class)
    .eq(User::getStatus, 1)
    .and(w -> w
        .gt(User::getAge, 18)
        .lt(User::getAge, 60)
    )
    .list();

// 生成 SQL：
// WHERE status = 1 AND (age > 18 AND age < 60)
```

### 混合嵌套

#### 示例1：复杂业务条件

```java
// 场景：查询 (状态正常) 且 (VIP用户 或 (普通用户且积分>100))
DB.query(User.class)
    .eq(User::getStatus, 1)
    .and(w -> w
        .eq(User::getVip, 1)
        .or(o -> o
            .eq(User::getVip, 0)
            .gt(User::getScore, 100)
        )
    )
    .list();

// 生成 SQL：
// WHERE status = 1 AND (vip = 1 OR (vip = 0 AND score > 100))
```

#### 示例2：菜单重复检查

```java
Menu menu = new Menu();
menu.setId(100L);
menu.setCode("user_mgmt");
menu.setName("用户管理");

WrapperQuery<Menu> query = DB.query(Menu.class);

// 排除自己
if (menu.getId() != null) {
    query.ne(Menu::getId, menu.getId());
}

// 编码相同 OR (名称相同 AND 分类相同)
query.or(w -> w
    .eq(Menu::getCode, menu.getCode())
    .and(a -> a
        .eq(Menu::getName, menu.getName())
        .eq(Menu::getCategory, "1")
    )
);

boolean exists = query.count() > 0;

// 生成 SQL：
// WHERE id <> 100 
//   AND (code = 'user_mgmt' OR (name = '用户管理' AND category = '1')) 
//   AND is_deleted = 0
```

### 使用 Condition 复用条件

```java
// 创建可复用的条件
Condition baseCondition = Condition.where()
    .eq("status", 1)
    .gt("age", 18);

Condition vipCondition = Condition.where()
    .eq("vip", 1)
    .gt("level", 5);

// 应用到查询
DB.query("user")
    .where(baseCondition)
    .or(w -> w.where(vipCondition))
    .list();

// 应用到更新
DB.update("user")
    .set("flag", 1)
    .where(baseCondition)
    .execute();
```

## 4.3 模糊查询

### LIKE 查询

| 方法 | 说明 | SQL 示例 |
|------|------|---------|
| `like(字段, 值)` | 包含 | `LIKE '%值%'` |
| `likeLeft(字段, 值)` | 左模糊 | `LIKE '%值'` |
| `likeRight(字段, 值)` | 右模糊 | `LIKE '值%'` |
| `notLike(字段, 值)` | 不包含 | `NOT LIKE '%值%'` |

### 使用示例

```java
DB.query(User.class)
    // 名字包含"张"
    .like(User::getName, "张")
    // 邮箱以 @gmail.com 结尾
    .likeLeft(User::getEmail, "@gmail.com")
    // 手机号以 138 开头
    .likeRight(User::getPhone, "138")
    // 地址不包含"测试"
    .notLike(User::getAddress, "测试")
    .list();

// 生成 SQL：
// WHERE name LIKE '%张%' 
//   AND email LIKE '%@gmail.com' 
//   AND phone LIKE '138%' 
//   AND address NOT LIKE '%测试%'
```

### 条件判断

```java
String keyword = request.getParameter("keyword");

DB.query(User.class)
    // keyword 不为空时才添加 LIKE 条件
    .like(StringUtil.isNotBlank(keyword), User::getName, keyword)
    .list();
```

### 注意事项

1. **空值处理**：当值为 null 或空字符串时，建议跳过条件
2. **性能考虑**：`likeLeft`（左模糊）无法使用索引，大数据量时慎用
3. **特殊字符**：框架会自动转义 `%` 和 `_` 等特殊字符


## 4.4 范围查询

### IN 查询

#### 基础 IN

```java
DB.query(User.class)
    .in(User::getId, Arrays.asList(1, 2, 3, 4, 5))
    .list();

// 生成 SQL：WHERE id IN (1, 2, 3, 4, 5)
```

#### 字符串 IN（自动解析）

```java
// 方式1：逗号分隔的数字
DB.query(User.class)
    .in(User::getId, "1,2,3,4,5")
    .list();
// 生成 SQL：WHERE id IN (1,2,3,4,5)

// 方式2：带引号的字符串
DB.query(User.class)
    .in(User::getCode, "'A','B','C'")
    .list();
// 生成 SQL：WHERE code IN ('A','B','C')

// 方式3：混合类型
DB.query(User.class)
    .in(User::getCode, "'A',111,'B',222")
    .list();
// 生成 SQL：WHERE code IN ('A','111','B','222')
```

#### 子查询 IN

```java
DB.query(User.class)
    .in(User::getDeptId, "sql:SELECT id FROM department WHERE status = 1")
    .list();

// 生成 SQL：WHERE dept_id IN (SELECT id FROM department WHERE status = 1)
```

#### NOT IN

```java
DB.query(User.class)
    .notIn(User::getStatus, Arrays.asList(0, -1))
    .list();

// 生成 SQL：WHERE status NOT IN (0, -1)
```

### BETWEEN 查询

```java
DB.query(User.class)
    .between(User::getAge, 18, 30)
    .between(User::getCreateTime, startDate, endDate)
    .list();

// 生成 SQL：
// WHERE age BETWEEN 18 AND 30 
//   AND create_time BETWEEN '2024-01-01' AND '2024-12-31'
```

### NOT BETWEEN

```java
DB.query(User.class)
    .notBetween(User::getScore, 0, 60)
    .list();

// 生成 SQL：WHERE score NOT BETWEEN 0 AND 60
```

### 综合示例

```java
// 查询条件：
// - ID 在列表中
// - 状态不在禁用列表
// - 年龄在 18-60 之间
// - 部门在子查询结果中

DB.query(User.class)
    .in(User::getId, "1,2,3,4,5")
    .notIn(User::getStatus, Arrays.asList(0, -1))
    .between(User::getAge, 18, 60)
    .in(User::getDeptId, "sql:SELECT id FROM dept WHERE type = 'tech'")
    .list();
```

## 4.5 自定义 SQL

### apply 方法（占位符方式）

使用 `{0}`, `{1}`, `{2}` 作为占位符：

```java
DB.query(User.class)
    .eq(User::getStatus, 1)
    .apply("age > {0} AND age < {1}", 18, 60)
    .list();

// 生成 SQL：
// WHERE status = 1 AND (age > 18 AND age < 60)
```

#### 子查询示例

```java
DB.query(User.class)
    .apply("id IN (SELECT user_id FROM orders WHERE amount > {0})", 1000)
    .list();

// 生成 SQL：
// WHERE (id IN (SELECT user_id FROM orders WHERE amount > 1000))
```

#### EXISTS 示例

```java
DB.query(User.class)
    .eq(User::getStatus, 1)
    .apply("EXISTS (SELECT 1 FROM vip WHERE user_id = t.id AND level >= {0})", 3)
    .list();
```

### sql 方法（命名参数方式）

使用 `#{参数名}` 作为命名参数：

```java
JSONMap params = new JSONMap("minAge", 18, "maxAge", 60);

DB.query(User.class)
    .eq(User::getStatus, 1)
    .sql("age > #{minAge} AND age < #{maxAge}", params)
    .list();

// 生成 SQL：
// WHERE status = 1 AND (age > 18 AND age < 60)
```

#### 复杂子查询示例

```java
JSONMap params = new JSONMap();
params.put("level", 3);
params.put("minAmount", 1000);

DB.query(User.class)
    .sql("EXISTS (SELECT 1 FROM orders o WHERE o.user_id = t.id AND o.amount > #{minAmount})", params)
    .sql("id IN (SELECT user_id FROM vip WHERE level >= #{level})", params)
    .list();
```

### 可选条件（方括号语法）

当参数为空时，整个条件自动忽略：

```java
String name = null;  // 前端未传
Integer minAge = 18;

DB.delete("user")
    .apply("[name = {0}]", name)      // name 为空，忽略此条件
    .apply("[age >= {0}]", minAge)    // minAge 有值，条件生效
    .execute();

// 生成 SQL：
// DELETE FROM user WHERE (age >= 18) AND is_deleted = 0
```

#### sql 方法同样支持

```java
JSONMap params = new JSONMap();
params.put("name", null);
params.put("age", 18);

DB.query("user")
    .sql("[name = #{name}]", params)  // 忽略
    .sql("[age >= #{age}]", params)   // 生效
    .list();
```

### 在 Condition 中使用

```java
Condition condition = Condition.where()
    .eq("status", 1)
    .sql("score > #{minScore}", new JSONMap("minScore", 60))
    .apply("create_time > {0}", someDate);

DB.query("user").where(condition).list();
DB.update("user").set("flag", 1).where(condition).execute();
```

### 安全提示

```java
// ✅ 安全：使用参数化查询
.apply("name = {0}", userInput)
.sql("name = #{name}", params)

// ⚠️ 危险：直接拼接用户输入
.apply("name = '" + userInput + "'")  // 可能 SQL 注入！
```
